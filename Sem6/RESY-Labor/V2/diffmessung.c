// program Differenzmessung
// Generated by Structorizer 3.31-02

#include <string.h>
#include <sched.h>
#include <pthread.h>
#include <sys/wait.h>
#include <stdlib.h>
#include "helpfunction.h"

// sleeping
#define USEC_IN_NANOSEC 1000
#define SLEEPING_FACTOR 1000
#define ITERATIONS 100

// aufgabe 1.2
// #define SLEEPING 3000

// rt
#define PRIORITY_OF_THIS_TASK 50
#define __USE_UNIX98 /* needed for PTHREAD_PRIO_INHERIT */

static pthread_mutex_t rtmutex;
static pthread_mutexattr_t attr;
char *Policies[] = {"SCHED_RR"};

int main(int argc, char **argv)
{
    // flags
    int flag_rt, flag_rtarch;
    flag_rt = flag_rtarch = 0;

#ifdef DEBUG
    if (argc > 1)
    {
        printf("diffmessung: args\n");
    }
#endif

    const char* const opt_rt = "-rt";         // priority
    const char* const opt_rtarch = "-rtarch"; //multicore
    for (int arg_index = 1; arg_index < argc; arg_index++)
    {
#ifdef DEBUG
        printf("diffmessung: setting %s flag\n", argv[arg_index]);
#endif
        if (strcmp(opt_rt, argv[arg_index]) == 0)
        {
            flag_rt = 1;
        }
        else if (strcmp(opt_rtarch, argv[arg_index]) == 0)
        {
            flag_rtarch = 1;
        }
    }

#ifdef DEBUG
    printf("rt: %d\n", flag_rt);
    printf("rtarch: %d\n", flag_rtarch);
#endif

    if (flag_rtarch == 1)
    {
        int parent_pid = (int)getpid();
        int child_pid = fork();
        if (child_pid < 0)
        {
            perror("Fork failed\n");
            exit(1);
        }
        else if (child_pid == 0)
        {
            // child
#ifdef DEBUG
            printf("diffmessung: child with pid %d\n", (int)getpid());
#endif
            char pid_as_string[10];
            sprintf(pid_as_string, "%d", parent_pid);

            // rtarch set-ups the rt environment, needs root privilege to write to /sys/ fs
            char *argument_list_rmmod[] = {"./rtarch.sh", pid_as_string, NULL};
            execvp("./rtarch.sh", argument_list_rmmod);
        }
        else
        {
#ifdef DEBUG
            printf("diffmessung: parent with pid %d\n", parent_pid);
            printf("diffmessung: waiting for child\n");
#endif
            wait(&child_pid);
        }
    }

    // rt flag
    struct sched_param SchedulingParameter;
    if (flag_rt == 1)
    {
#ifdef DEBUG
        printf("diffmessung: setup rt\n");
#endif
        // setup rt
        pthread_mutexattr_init(&attr);
        pthread_mutexattr_setprotocol(&attr, PTHREAD_PRIO_INHERIT);
        pthread_mutex_init(&rtmutex, &attr);

        SchedulingParameter.sched_priority = PRIORITY_OF_THIS_TASK;
        if (sched_setscheduler(0, SCHED_RR, &SchedulingParameter) != 0)
        {
            perror("diffmessung: set scheduling priority failed\n");
            exit(-1);
        }
    }

    struct timespec start_sleep, end_sleep;
    struct timespec timestamp;
    struct timespec result_sleep;
    struct timespec difference_sleep;
    time_t results_list[ITERATIONS];

    for (int sleeping = 0; sleeping <= 50; sleeping++)
    {

        // aufgabe 1.2
        // time_t sleeping_time = SLEEPING * USEC_IN_NANOSEC;

        time_t sleeping_time = sleeping * SLEEPING_FACTOR * USEC_IN_NANOSEC;
#ifdef DEBUG
        printf("--------------------------------\n");
        printf("diffmessung: sleeping for %ld ns\n", sleeping_time);
#endif
        for (int i = 1; i <= ITERATIONS; i++)
        {
            // init
            timestamp.tv_sec = 0;
            timestamp.tv_nsec = sleeping_time;

            // time measurement
            clock_gettime(CLOCK_MONOTONIC, &start_sleep);
            clock_nanosleep(CLOCK_MONOTONIC, 0, &timestamp, NULL);
            clock_gettime(CLOCK_MONOTONIC, &end_sleep);

            // calc diff time
            Difftime(&start_sleep, &end_sleep, &result_sleep);
            difference_sleep.tv_nsec = result_sleep.tv_nsec - sleeping_time;
#ifdef DEBUG
            printf("diffmessung: slept for %ld ns\n", result_sleep.tv_nsec);
#endif
            results_list[i - 1] = difference_sleep.tv_nsec;
        }

        // aufgabe 1.2
        // printf("%d ", SLEEPING);

        printf("%d ", sleeping * SLEEPING_FACTOR);

        // min
        time_t min = results_list[0];
        for (int i = 0; i < ITERATIONS; i++)
        {
            if (results_list[i] < min)
            {
                min = results_list[i];
            }
        }
        min = (time_t)(min / USEC_IN_NANOSEC);
        printf("%ld ", min);

        // median
        time_t sum = 0;
        for (int i = 0; i < ITERATIONS; i++)
        {
            sum += results_list[i];
        }
        time_t med = (time_t)((sum / ITERATIONS) / USEC_IN_NANOSEC);
        printf("%ld ", med);

        // max
        time_t max = results_list[0];
        for (int i = 0; i < ITERATIONS; i++)
        {
            if (results_list[i] > max)
            {
                max = results_list[i];
            }
        }
        max = (time_t)(max / USEC_IN_NANOSEC);
        printf("%ld\n", max);

        if (max < med || min > max || min > med)
        {
            perror("diffmessung: wrong calculations of time!");
            exit(1);
        }
    }

    return 0;
}